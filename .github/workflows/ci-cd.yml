name: React Vite + Nginx CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - '.gitignore'
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - demo

env:
  NODE_VERSION: '20'
  DEPLOY_URL: ${{ secrets.DEPLOY_URL || 'http://192.168.111.200' }}
  MCP_SERVER_URL: ${{ secrets.MCP_SERVER_URL || 'http://192.168.111.200:8080' }}
  DEPLOY_PATH: ${{ secrets.DEPLOY_PATH || '/root/mcp_containers' }}

jobs:
  test:
    runs-on: ubuntu-latest
    name: üß™ Run Tests
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint
        continue-on-error: false

      - name: Run tests
        run: npm test -- --run
        continue-on-error: false

  build:
    runs-on: ubuntu-latest
    needs: test
    name: üî® Build Application
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build
        env:
          NODE_ENV: production

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: dist/
          retention-days: 30

  deploy:
    runs-on: ${{ github.ref == 'refs/heads/main' && 'self-hosted' || 'ubuntu-latest' }}
    needs: build
    name: üöÄ Deploy to Production
    if: github.event_name != 'pull_request'
    environment:
      name: ${{ github.ref == 'refs/heads/main' && 'production' || 'demo' }}
      url: ${{ env.DEPLOY_URL }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: dist/

      - name: Verify MCP Server connectivity
        if: github.ref == 'refs/heads/main'
        run: |
          echo "üîç Testing MCP server connectivity..."
          response=$(curl -X POST "$MCP_SERVER_URL" \
            -H "Content-Type: application/json" \
            -d '{"jsonrpc":"2.0","method":"get_system_info","params":{},"id":1}' \
            --connect-timeout 10 \
            --max-time 30 \
            --fail \
            --silent) || {
            echo "‚ùå Cannot connect to MCP server at $MCP_SERVER_URL"
            exit 1
          }
          
          echo "‚úÖ MCP server connected successfully"

      - name: Deploy to Server (Production)
        if: github.ref == 'refs/heads/main'
        env:
          PROJECT_NAME: ${{ github.event.repository.name }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_RUN_NUMBER: ${{ github.run_number }}
        run: |
          echo "üöÄ Starting React+Vite+Nginx production deployment"
          echo "üì¶ Repository: ${{ github.repository }}"
          echo "üîÑ Commit: ${{ github.sha }}"
          echo "üèÉ Run: #${{ github.run_number }}"
          
          # Create timestamped release directory
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          RELEASE_DIR="$DEPLOY_PATH/releases/$TIMESTAMP"
          
          echo "üìÅ Creating release directory: $RELEASE_DIR"
          curl -X POST "$MCP_SERVER_URL" \
            -H "Content-Type: application/json" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"mkdir -p $RELEASE_DIR\"},\"id\":1}"
          
          # Deploy React build files using chunked approach for large files
          echo "üìÇ Deploying React build files..."
          for file in dist/*; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              echo "üìù Deploying: $filename"
              
              # Check file size
              file_size=$(wc -c < "$file")
              echo "üîç File size: $file_size bytes"
              
              if [ "$file_size" -gt 50000 ]; then
                # Large file: use temporary file approach
                echo "‚ö†Ô∏è Large file detected, using alternative method..."
                
                # Create temporary file on server
                temp_filename="/tmp/deploy_$(date +%s)_$filename"
                curl -X POST "$MCP_SERVER_URL" \
                  -H "Content-Type: application/json" \
                  -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"touch $temp_filename\"},\"id\":1}"
                
                # Split file and send in chunks
                split -b 40000 "$file" "/tmp/chunk_"
                for chunk in /tmp/chunk_*; do
                  if [ -f "$chunk" ]; then
                    encoded_chunk=$(base64 -w 0 "$chunk")
                    curl -X POST "$MCP_SERVER_URL" \
                      -H "Content-Type: application/json" \
                      -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"echo '$encoded_chunk' | base64 -d >> $temp_filename\"},\"id\":1}"
                    rm "$chunk"
                  fi
                done
                
                # Move to final location
                curl -X POST "$MCP_SERVER_URL" \
                  -H "Content-Type: application/json" \
                  -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"mv $temp_filename $RELEASE_DIR/$filename\"},\"id\":1}"
                
              else
                # Small file: use original method
                encoded_content=$(base64 -w 0 "$file")
                curl -X POST "$MCP_SERVER_URL" \
                  -H "Content-Type: application/json" \
                  -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"echo '$encoded_content' | base64 -d > $RELEASE_DIR/$filename\"},\"id\":1}"
              fi
              
              echo "‚úÖ SUCCESS: $filename deployed"
            fi
          done
          
          # Deploy assets directory if exists
          if [ -d "dist/assets" ]; then
            echo "üìÇ Deploying assets directory..."
            curl -X POST "$MCP_SERVER_URL" \
              -H "Content-Type: application/json" \
              -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"mkdir -p $RELEASE_DIR/assets\"},\"id\":1}"
            
            for asset in dist/assets/*; do
              if [ -f "$asset" ]; then
                asset_name=$(basename "$asset")
                echo "üìù Deploying asset: $asset_name"
                
                # Check asset file size
                asset_size=$(wc -c < "$asset")
                echo "üîç Asset size: $asset_size bytes"
                
                if [ "$asset_size" -gt 50000 ]; then
                  # Large asset: use chunked approach
                  echo "‚ö†Ô∏è Large asset detected, using chunked method..."
                  temp_asset="/tmp/deploy_asset_$(date +%s)_$asset_name"
                  
                  curl -X POST "$MCP_SERVER_URL" \
                    -H "Content-Type: application/json" \
                    -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"touch $temp_asset\"},\"id\":1}"
                  
                  split -b 40000 "$asset" "/tmp/asset_chunk_"
                  for chunk in /tmp/asset_chunk_*; do
                    if [ -f "$chunk" ]; then
                      encoded_chunk=$(base64 -w 0 "$chunk")
                      curl -X POST "$MCP_SERVER_URL" \
                        -H "Content-Type: application/json" \
                        -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"echo '$encoded_chunk' | base64 -d >> $temp_asset\"},\"id\":1}"
                      rm "$chunk"
                    fi
                  done
                  
                  curl -X POST "$MCP_SERVER_URL" \
                    -H "Content-Type: application/json" \
                    -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"mv $temp_asset $RELEASE_DIR/assets/$asset_name\"},\"id\":1}"
                else
                  # Small asset: use original method
                  encoded_asset=$(base64 -w 0 "$asset")
                  curl -X POST "$MCP_SERVER_URL" \
                    -H "Content-Type: application/json" \
                    -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"echo '$encoded_asset' | base64 -d > $RELEASE_DIR/assets/$asset_name\"},\"id\":1}"
                fi
                
                echo "‚úÖ SUCCESS: assets/$asset_name deployed"
              fi
            done
          fi
          
          # Copy files to app container build directory
          echo "üîó Preparing container deployment..."
          curl -X POST "$MCP_SERVER_URL" \
            -H "Content-Type: application/json" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"rm -rf $DEPLOY_PATH/app/src/* && cp -r $RELEASE_DIR/* $DEPLOY_PATH/app/src/\"},\"id\":1}"
          
          # Build new Docker image with Nginx
          echo "üèóÔ∏è Building React+Nginx container image..."
          curl -X POST "$MCP_SERVER_URL" \
            -H "Content-Type: application/json" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"cd $DEPLOY_PATH/app && docker build -t mcp-app:$TIMESTAMP .\"},\"id\":1}"
          
          # Zero-downtime container replacement
          echo "üîÑ Starting zero-downtime deployment..."
          
          # Start new container
          curl -X POST "$MCP_SERVER_URL" \
            -H "Content-Type: application/json" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"docker run -d --name mcp-app-new --network mcp-network --hostname app -p 81:3000 mcp-app:$TIMESTAMP\"},\"id\":1}"
          
          # Wait for new container to be ready
          echo "‚è≥ Waiting for new container to be ready..."
          sleep 5
          
          # Health check new container
          health_response=$(curl -X POST "$MCP_SERVER_URL" \
            -H "Content-Type: application/json" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"curl -s http://localhost:81/health --connect-timeout 5 || echo 'Health check failed'\"},\"id\":1}")
          
          echo "üè• Health check result: $health_response"
          
          # Switch traffic (stop old, promote new)
          echo "üîÑ Switching traffic to new container..."
          curl -X POST "$MCP_SERVER_URL" \
            -H "Content-Type: application/json" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"docker stop mcp-app 2>/dev/null || echo 'No old container'; docker rm mcp-app 2>/dev/null || echo 'No old container to remove'\"},\"id\":1}"
          
          curl -X POST "$MCP_SERVER_URL" \
            -H "Content-Type: application/json" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"docker stop mcp-app-new && docker rm mcp-app-new\"},\"id\":1}"
          
          curl -X POST "$MCP_SERVER_URL" \
            -H "Content-Type: application/json" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"docker run -d --name mcp-app --network mcp-network --hostname app -p 80:3000 mcp-app:$TIMESTAMP\"},\"id\":1}"
          
          # Wait for final container to stabilize
          echo "‚è≥ Waiting for final container to stabilize..."
          sleep 15
          
          # Robust health check for production container
          echo "üè• Performing robust health check..."
          for attempt in {1..10}; do
            health_check=$(curl -X POST "$MCP_SERVER_URL" \
              -H "Content-Type: application/json" \
              -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"curl -s -w 'HTTP_CODE:%{http_code}' http://localhost/health --connect-timeout 3 --max-time 10\"},\"id\":1}")
            
            if echo "$health_check" | grep -q "HTTP_CODE:200"; then
              echo "‚úÖ Production container health check passed (attempt $attempt/10)"
              break
            else
              echo "‚è≥ Health check attempt $attempt/10 failed, retrying..."
              sleep 3
            fi
            
            if [ "$attempt" -eq 10 ]; then
              echo "‚ùå Production container health check failed after 10 attempts"
              exit 1
            fi
          done
          
          # Cleanup old images (keep latest 3)
          echo "üßπ Cleaning up old Docker images..."
          curl -X POST "$MCP_SERVER_URL" \
            -H "Content-Type: application/json" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"docker images mcp-app --format '{{.Tag}}' | grep -E '^[0-9]{8}_[0-9]{6}$' | sort -r | tail -n +4 | xargs -r -I {} docker rmi mcp-app:{} 2>/dev/null || echo 'No old images to remove'\"},\"id\":1}"
          
          # Cleanup old releases (keep latest 5)
          echo "üßπ Cleaning up old releases..."
          curl -X POST "$MCP_SERVER_URL" \
            -H "Content-Type: application/json" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"execute_command\",\"params\":{\"command\":\"cd $DEPLOY_PATH/releases && ls -1t | tail -n +6 | xargs -r rm -rf\"},\"id\":1}"
          
          echo "üéâ React+Vite+Nginx deployment completed successfully!"
          echo "üìä Container image: mcp-app:$TIMESTAMP"
          echo "üåê Application URL: $DEPLOY_URL/dashboard"

      - name: Deploy to Server (Demo Mode)
        if: github.ref != 'refs/heads/main'
        run: |
          echo "üöÄ Starting demo deployment"
          echo "üì¶ Repository: ${{ github.repository }}"
          echo "üåø Branch: ${{ github.ref_name }}"
          echo "‚úÖ Demo deployment completed"

  post-deployment-tests:
    runs-on: self-hosted
    needs: deploy
    name: üß™ Post-Deployment Tests
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Run post-deployment verification
        run: |
          echo "üß™ Running post-deployment verification..."
          
          # Wait for deployment to fully stabilize
          echo "‚è≥ Waiting for deployment to stabilize..."
          sleep 10
          
          # Test main application endpoint
          echo "üåê Testing main application endpoint..."
          for attempt in {1..8}; do
            response=$(curl -s -w "HTTP_CODE:%{http_code}" "$DEPLOY_URL/dashboard" --connect-timeout 10 --max-time 30) || {
              echo "‚è≥ Connection attempt $attempt/8 failed, retrying..."
              sleep 8
              continue
            }
            
            if echo "$response" | grep -q "HTTP_CODE:200"; then
              echo "‚úÖ SUCCESS: Main application accessible (attempt $attempt/8)"
              break
            else
              echo "‚è≥ Application test attempt $attempt/8 failed, retrying..."
              sleep 8
            fi
          done
          
          # Test API endpoints
          echo "üîó Testing API endpoints..."
          api_endpoints=("/api/system" "/api/health" "/api/resources" "/api/server-stats" "/api/containers")
          
          for endpoint in "${api_endpoints[@]}"; do
            echo "üß™ Testing $endpoint..."
            api_response=$(curl -s -w "HTTP_CODE:%{http_code}" "$DEPLOY_URL$endpoint" --connect-timeout 5 --max-time 15)
            
            if echo "$api_response" | grep -q "HTTP_CODE:200"; then
              echo "‚úÖ SUCCESS: $endpoint is responding"
            else
              echo "‚ö†Ô∏è WARNING: $endpoint may have issues"
            fi
          done
          
          echo "‚úÖ Post-deployment verification completed"

  performance:
    runs-on: ubuntu-latest
    needs: build
    name: üéØ Performance Tests
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: dist/

      - name: Check bundle size
        run: |
          echo "üìä Analyzing bundle size..."
          du -sh dist/
          find dist -name "*.js" -exec ls -lh {} \;
          find dist -name "*.css" -exec ls -lh {} \;
          
          # Check if bundle is too large (warning if > 1MB)
          js_size=$(find dist -name "*.js" -exec ls -l {} \; | awk '{sum += $5} END {print sum}')
          if [ "$js_size" -gt 1048576 ]; then
            echo "‚ö†Ô∏è WARNING: JavaScript bundle size is large ($(echo $js_size | numfmt --to=iec))"
            echo "Consider code splitting or optimization"
          else
            echo "‚úÖ Bundle size is acceptable ($(echo $js_size | numfmt --to=iec))"
          fi

  notify:
    runs-on: ubuntu-latest
    needs: [test, build, deploy, post-deployment-tests, performance]
    name: üì¢ Deployment Notifications
    if: always()
    steps:
      - name: Deployment Summary
        run: |
          # Set deployment type
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            DEPLOY_TYPE="Production"
            DEPLOY_TARGET="React + Vite + Nginx (Dockerized)"
          else
            DEPLOY_TYPE="Demo"
            DEPLOY_TARGET="Simulation Mode"
          fi
          
          echo "## üöÄ $DEPLOY_TYPE Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository:** ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run:** #${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy Type:** $DEPLOY_TYPE" >> $GITHUB_STEP_SUMMARY
          echo "- **Target:** $DEPLOY_TARGET" >> $GITHUB_STEP_SUMMARY
          echo "- **Framework:** React + Vite + React Router + Nginx" >> $GITHUB_STEP_SUMMARY
          echo "- **Containerization:** Docker + Zero-downtime deployment" >> $GITHUB_STEP_SUMMARY
          echo "- **URL:** $DEPLOY_URL/dashboard" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** ${{ needs.deploy.result == 'success' && '‚úÖ Success' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Post-Deploy Tests:** ${{ needs.post-deployment-tests.result == 'success' && '‚úÖ Passed' || needs.post-deployment-tests.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Performance:** ${{ needs.performance.result == 'success' && '‚úÖ Passed' || '‚ö†Ô∏è Check Required' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "üéâ $DEPLOY_TYPE deployment completed successfully!"
            if [ "${{ github.ref }}" == "refs/heads/main" ]; then
              echo "üåê Application is now live at: $DEPLOY_URL/dashboard"
              echo "üè• Health Check: $DEPLOY_URL/health"
              echo "üìä System Monitor: $DEPLOY_URL/dashboard"
            fi
          else
            echo "‚ùå $DEPLOY_TYPE deployment failed. Check logs for details."
            exit 1
          fi